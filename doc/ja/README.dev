comment -*- mode: text -*-
comment $Id$

開発者向けドキュメント(2.0.0対応)

御世辞にもきれいとはいえないソースですが、いじりたいという奇特な方がいらっしゃる
かもしれませんので、ソースを読む際の手助けとなる情報をドキュメントしておきます。
概略的なことに留めていますので、実装の詳細については、実際のソースコードをお読
み下さい。

また、ここに記載されている内容は、2.0.0以降も妥当するとは限りません。


* 全体像の俯瞰
  mltermは、大きくわけて、3つのモジュールから構成されています。

  1.kiklib/src
    汎用ライブラリです。
    ユーティリティの実装だけではなく、異なるOS間の差異の吸収もここで行ないます。

  2.mkf/lib
    文字コードを解釈/変換するためのライブラリ群です。
    
  3.mlterm/src
    VT100互換のX端末のコア機能を実装しています。
  
  以下では、2および3のモジュールについて説明します。
  
* mkf
  重要なファイルは、以下の3つです。

  mkf_char.h
  mkf_parser.h
  mkf_conv.h

  mkf_char.hでは、mkfライブラリが、文字列を取り扱う際の単位となる、mkf_char_tが定
  義されています。
  mkf_char_tには、バイト列と文字集合情報(*)が保持されます。

  (*) 文字集合情報は、mkf_charset.h でまとめて定義されています。
  
  mkf_parser.h , mkf_conv.hでは、それぞれ、mkf_parser_t , mkf_conv_tという二つの構
  造体が定義されています。
  これらは、mkfライブラリの最も基本的なインターフェースになります。
  前者は、エンコーディングの解釈を行ない、後者は、mkf_parser_tで解釈されてとりだ
  されてきた文字(mkf_char_t)一つ一つを、特定のエンコーディングに変換します。

  mkf_parser_t , mkf_conv_tは、基底クラスに相当する役割をはたし、それ単体では、
  何もできません。実際の挙動は、それらをどのように実装するかによって決まります。
  具体的には、前者の、init , delete , set_str , next_char という4つのメソッドお
  よび、後者の、init , delete , convert という3つのメソッドを、それぞれのエンコーディン
  グに応じて実装してやることになります。
  
  mkf_parser_t , mkf_conv_t の実装は、mkf_*_parser.{ch} , mkf_*_conv.{ch}という
  一連のモジュールによって行なわれています。
  各 mkf_*_parser , mkf_*_conv モジュールは、mkf_*_parser_new , mkf_*_conv_newと
  いう、それぞれのエンコーディングに対応した mkf_parser_t , mkf_conv_t を生成す
  るコンストラクタを提供し、利用者は、それによって得られた mkf_parser_t , mkf_conv_t
  を使って、文字コード処理を行なうことになります。
  
  また、mkfでは、mkf_*_map.{ch} というモジュールも用意されています。
  これらは、上記のようなエンコーディング処理ではなく、各文字集合同士の mapping
  を行ないます。
  関数名は、mkf_map_[src charset]_to_[dst charset] という形で統一されています。

  ちなみに、mkf_*_map モジュールは、多くの mkf_*_conv モジュール内部でも利用され
  ています。
  つまり、もし、変換対象として受けとった文字の文字集合が、その mkf_*_conv モジュ
  ールのエンコーディングに対応していないものであったとしても、mkf_*_map モジュー
  ルを使って、できるだけ、そのエンコーディングに対応した文字集合に変換するよう努
  力しています。

* mlterm
  X端末の実装は、処理するイベントの種別によって、大きく以下の 3 つのモジュールに
  分類されます。

  1. イベント管理
  2. pty イベント処理
  3. X Window System イベント処理

  以下では、それぞれについて説明します。

  o イベント管理
    X端末には、X Window Systemからのイベントと、ptyからのイベントという、2つのイ
    ベントソースがあります。
    mltermでは、この両者を一括して管理し、それらのイベントを適切なモジュールへと
    dispatch しています。この役割をになっているのが、ml_term_manager です。

    ml_term_manager は、上記の二つのイベントを待ち受け、イベントが発生したことを
    検知すると(select(2))、それが、X Window System からのものなら、
    ml_window_manager に、pty からのものなら、ml_vt100_parser に伝えます。
    (see receive_next_event())

  o X Window System イベント処理
    X Window System での Window 一つ一つは、 ml_window_t 構造体に対応しています。
    そして、すべての Window (ml_window)は、ml_window_manager を頂点として、ツリー
    状に配置されています。
    X Window System からのイベントが、ml_window_manager に伝えられると、そのツリ
    ーを辿って、適切な Window に伝えられるようになっています。

  o pty イベント処理
    このイベントを受けとるのは、 ml_vt100_parser です。
    ml_vt100_parser は、pty入出力を管理している ml_pty への参照を保持しており、
    そこから一連のVT100シーケンスを読み出して解釈します。

    解釈した結果は、実際の VT100 互換画面描画を管理する、ml_term_screen へと送ら
    れます。

    ml_term_screen は、VT100互換画面を実際に描画します。
    このために、まず、ml_window_t を継承して、ウィンドウ画面への描画を可能にして
    います。
    また、ml_image という抽象的な画面イメージも保持しており、ml_vt100_parser か
    らの要求を受けると、まずは、ml_image を適切に操作します。
    そして、適当なタイミングで、ml_image に加えた変更差分をウィンドウ画面に描画
    しています。
    ちなみに、ここでいう、ml_term_screen と ml_vt100_parser 相互のやりとりが、上
    記の2番目と3番目のモジュール間のやりとりに、ほぼ相当します。

  実際には、このようにすっきりとわけられているわけではなく、各モジュール相互で、
  複雑に通信・協調しつつ、動作しています。
  
  また、これ以外については、これら3つのモジュールを支援するための周辺モジュールに
  なります。その役割については、大体、そのファイル名から想像がつくと思われますの
  で、ここでの説明はいたしません。

  ご不明の点や、ご意見などは、j00v0113@ip.media.kyoto-u.ac.jp まで御連絡ください。

以上。
