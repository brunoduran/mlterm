diff -r e3b32d39b47a display.c
--- a/display.c
+++ b/display.c
@@ -487,7 +487,7 @@
     term_title(conv_to_system(buf->buffername));
     refresh();
 #ifdef USE_IMAGE
-    if (activeImage && displayImage && buf->img) {
+    if (activeImage && displayImage && buf->img && buf->image_loaded) {
 	drawImage();
     }
 #endif
@@ -521,7 +521,10 @@
 		break;
 	}
 	if (hseq >= 0 && an->hseq == hseq) {
+	    int hasImage = 0;
 	    for (i = an->start.pos; i < an->end.pos; i++) {
+	        if (l->propBuf[i] & PE_IMAGE)
+		    hasImage = 1 ;
 		if (l->propBuf[i] & (PE_IMAGE | PE_ANCHOR | PE_FORM)) {
 		    if (active)
 			l->propBuf[i] |= PE_ACTIVE;
@@ -529,7 +532,8 @@
 			l->propBuf[i] &= ~PE_ACTIVE;
 		}
 	    }
-	    if (active)
+	    if (active &&
+	        (! support_remote_image || ! hasImage))
 		redrawLineRegion(buf, l, l->linenumber - tline + buf->rootY,
 				 an->start.pos, an->end.pos);
 	}
@@ -855,14 +859,16 @@
 		y = (int)(i * pixel_per_line);
 		sx = (int)((rcol - COLPOS(l, a->start.pos)) * pixel_per_char);
 		sy = (int)((l->linenumber - image->y) * pixel_per_line);
-		if (sx == 0 && x + image->xoffset >= 0)
-		    x += image->xoffset;
-		else
-		    sx -= image->xoffset;
-		if (sy == 0 && y + image->yoffset >= 0)
-		    y += image->yoffset;
-		else
-		    sy -= image->yoffset;
+		if (! support_remote_image) {
+		    if (sx == 0 && x + image->xoffset >= 0)
+			x += image->xoffset;
+		    else
+			sx -= image->xoffset;
+		    if (sy == 0 && y + image->yoffset >= 0)
+			y += image->yoffset;
+		    else
+			sy -= image->yoffset;
+		}
 		if (image->width > 0)
 		    w = image->width - sx;
 		else
diff -r e3b32d39b47a file.c
--- a/file.c
+++ b/file.c
@@ -3378,19 +3378,21 @@
 	if (i0 >= 0)
 	    Strcat(tmp, Sprintf(" height=%d", i0));
 	switch (align) {
+	case ALIGN_MIDDLE:
+	    if (!support_remote_image) {
+		top = ni / 2;
+		bottom = top;
+		if (top * 2 == ni)
+		    yoffset = (int)(((ni + 1) * pixel_per_line - i) / 2);
+		else
+		    yoffset = (int)((ni * pixel_per_line - i) / 2);
+		break;
+	    }
 	case ALIGN_TOP:
 	    top = 0;
 	    bottom = ni - 1;
 	    yoffset = 0;
 	    break;
-	case ALIGN_MIDDLE:
-	    top = ni / 2;
-	    bottom = top;
-	    if (top * 2 == ni)
-		yoffset = (int)(((ni + 1) * pixel_per_line - i) / 2);
-	    else
-		yoffset = (int)((ni * pixel_per_line - i) / 2);
-	    break;
 	case ALIGN_BOTTOM:
 	    top = ni - 1;
 	    bottom = 0;
@@ -3408,7 +3410,12 @@
 	    }
 	    break;
 	}
-	xoffset = (int)((nw * pixel_per_char - w) / 2);
+
+	if (support_remote_image)
+	    xoffset = 0;
+	else
+	    xoffset = (int)((nw * pixel_per_char - w) / 2);
+
 	if (xoffset)
 	    Strcat(tmp, Sprintf(" xoffset=%d", xoffset));
 	if (yoffset)
diff -r e3b32d39b47a fm.h
--- a/fm.h
+++ b/fm.h
@@ -362,6 +362,8 @@
     int index;
     short width;
     short height;
+    short a_width;
+    short a_height;
 } ImageCache;
 
 typedef struct _image {
@@ -896,6 +898,7 @@
 global char *CurrentCmdData;
 global char *w3m_reqlog;
 extern char *w3m_version;
+extern int support_remote_image;
 
 #define DUMP_BUFFER   0x01
 #define DUMP_HEAD     0x02
@@ -1150,9 +1153,11 @@
 global int is_redisplay init(FALSE);
 global int clear_buffer init(TRUE);
 global double pixel_per_char init(DEFAULT_PIXEL_PER_CHAR);
+global int pixel_per_char_i init(DEFAULT_PIXEL_PER_CHAR);
 global int set_pixel_per_char init(FALSE);
 #ifdef USE_IMAGE
 global double pixel_per_line init(DEFAULT_PIXEL_PER_LINE);
+global int pixel_per_line_i init(DEFAULT_PIXEL_PER_LINE);
 global int set_pixel_per_line init(FALSE);
 global double image_scale init(100);
 #endif
diff -r e3b32d39b47a image.c
--- a/image.c
+++ b/image.c
@@ -52,6 +52,20 @@
     int w = 0, h = 0;
 
     set_environ("W3M_TTY", ttyname_tty());
+
+    if (support_remote_image) {
+	int ppc, ppl;
+
+	if (get_pixel_per_cell(&ppc,&ppl)) {
+	    pixel_per_char_i = ppc ;
+	    pixel_per_line_i = ppl ;
+	    pixel_per_char = (double)ppc;
+	    pixel_per_line = (double)ppl;
+	}
+
+	return  TRUE;
+    }
+
     tmp = Strnew();
     if (!strchr(Imgdisplay, '/'))
 	Strcat_m_charp(tmp, w3m_auxbin_dir(), "/", NULL);
@@ -155,6 +169,10 @@
 static void
 syncImage(void)
 {
+    if (support_remote_image) {
+	return;
+    }
+
     fputs("3;\n", Imgdisplay_wf);	/* XSync() */
     fputs("4;\n", Imgdisplay_wf);	/* put '\n' */
     while (fflush(Imgdisplay_wf) != 0) {
@@ -176,6 +194,7 @@
     static char buf[64];
     int j, draw = FALSE;
     TerminalImage *i;
+    struct stat st ;
 
     if (!activeImage)
 	return;
@@ -183,6 +202,48 @@
 	return;
     for (j = 0; j < n_terminal_image; j++) {
 	i = &terminal_image[j];
+
+	if (support_remote_image) {
+	#if 0
+	    fprintf(stderr,"file %s x %d y %d w %d h %d sx %d sy %d sw %d sh %d (ppc %d ppl %d)\n",
+		getenv("WINDOWID") ? i->cache->file : i->cache->url,
+		i->x, i->y,
+		i->cache->width > 0 ? i->cache->width : 0,
+		i->cache->height > 0 ? i->cache->height : 0,
+		i->sx, i->sy, i->width, i->height,
+		pixel_per_char_i, pixel_per_line_i);
+	#endif
+	    put_image(
+	    #if 1
+		/* XXX I don't know why but sometimes i->cache->file doesn't exist. */
+		getenv("WINDOWID") && (stat(i->cache->file,&st) == 0) ?
+			/* local */ i->cache->file : /* remote */ i->cache->url,
+	    #else
+		i->cache->url,
+	    #endif
+		i->x / pixel_per_char_i,
+		i->y / pixel_per_line_i,
+	    #if 1
+		i->cache->a_width > 0 ?
+			(i->cache->width + i->x % pixel_per_char_i + pixel_per_char_i - 1) /
+				pixel_per_char_i :
+	    #endif
+			0,
+
+	    #if 1
+		i->cache->a_height > 0 ?
+			(i->cache->height + i->y % pixel_per_line_i + pixel_per_line_i - 1) /
+				pixel_per_line_i :
+	    #endif
+			0,
+		i->sx / pixel_per_char_i,
+		i->sy / pixel_per_line_i,
+		(i->width + i->sx % pixel_per_char_i + pixel_per_char_i - 1) / pixel_per_char_i,
+		(i->height + i->sy % pixel_per_line_i + pixel_per_line_i - 1) / pixel_per_line_i);
+
+	    continue ;
+	}
+
 	if (!(i->cache->loaded & IMG_FLAG_LOADED &&
 	      i->width > 0 && i->height > 0))
 	    continue;
@@ -206,9 +267,15 @@
 	fputs("\n", Imgdisplay_wf);
 	draw = TRUE;
     }
-    if (!draw)
-	return;
-    syncImage();
+
+    if (!support_remote_image) {
+	if (!draw)
+	    return;
+	syncImage();
+    }
+    else
+	n_terminal_image = 0;
+
     touch_cursor();
     refresh();
 }
@@ -320,6 +387,8 @@
 	}
     }
     if (n) {
+        if (support_remote_image && n == l)
+	    drawImage();
 	message(Sprintf("%d/%d images loaded", l, n)->ptr,
 		buf->cursorX + buf->rootX, buf->cursorY + buf->rootY);
 	refresh();
@@ -403,7 +472,8 @@
     }
 
     if (draw && image_buffer) {
-	drawImage();
+        if (!support_remote_image)
+	    drawImage();
 	showImageProgress(image_buffer);
     }
 
@@ -496,8 +566,21 @@
 	cache->pid = 0;
 	cache->index = 0;
 	cache->loaded = IMG_FLAG_UNLOADED;
-	cache->width = image->width;
-	cache->height = image->height;
+	if (support_remote_image) {
+	    if (image->width > 0 && image->width % pixel_per_char_i > 0)
+		image->width += (pixel_per_char_i - image->width % pixel_per_char_i);
+
+	    if (image->height > 0 && image->height % pixel_per_line_i > 0)
+		image->height += (pixel_per_line_i - image->height % pixel_per_line_i);
+
+	    if (! getenv("WINDOWID") && image->height > 0 && image->width > 0)
+		cache->loaded = IMG_FLAG_LOADED;
+	}
+
+	cache->width = image->width ;
+	cache->height = image->height ;
+	cache->a_width = image->width;
+	cache->a_height = image->height;
 	putHash_sv(image_hash, key->ptr, (void *)cache);
     }
     if (flag != IMG_FLAG_SKIP) {
@@ -558,11 +641,11 @@
     }
     else if (cache->width < 0) {
 	int tmp = (int)((double)cache->height * w / h + 0.5);
-	cache->width = (tmp > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : tmp;
+	cache->a_width = cache->width = (tmp > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : tmp;
     }
     else if (cache->height < 0) {
 	int tmp = (int)((double)cache->width * h / w + 0.5);
-	cache->height = (tmp > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : tmp;
+	cache->a_height = cache->height = (tmp > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : tmp;
     }
     if (cache->width == 0)
 	cache->width = 1;
diff -r e3b32d39b47a istream.c
--- a/istream.c
+++ b/istream.c
@@ -22,8 +22,8 @@
 static void basic_close(int *handle);
 static int basic_read(int *handle, char *buf, int len);
 
-static void file_close(struct file_handle *handle);
-static int file_read(struct file_handle *handle, char *buf, int len);
+static void file_close(struct _file_handle *handle);
+static int file_read(struct _file_handle *handle, char *buf, int len);
 
 static int str_read(Str handle, char *buf, int len);
 
@@ -114,7 +114,7 @@
     stream = New(union input_stream);
     init_base_stream(&stream->base, STREAM_BUF_SIZE);
     stream->file.type = IST_FILE;
-    stream->file.handle = New(struct file_handle);
+    stream->file.handle = New(struct _file_handle);
     stream->file.handle->f = f;
     if (closep)
 	stream->file.handle->close = closep;
@@ -658,13 +658,13 @@
 }
 
 static void
-file_close(struct file_handle *handle)
+file_close(struct _file_handle *handle)
 {
     handle->close(handle->f);
 }
 
 static int
-file_read(struct file_handle *handle, char *buf, int len)
+file_read(struct _file_handle *handle, char *buf, int len)
 {
     return fread(buf, 1, len, handle->f);
 }
diff -r e3b32d39b47a istream.h
--- a/istream.h
+++ b/istream.h
@@ -20,7 +20,7 @@
 
 typedef struct stream_buffer *StreamBuffer;
 
-struct file_handle {
+struct _file_handle {
     FILE *f;
     void (*close) ();
 };
@@ -53,7 +53,7 @@
 
 struct file_stream {
     struct stream_buffer stream;
-    struct file_handle *handle;
+    struct _file_handle *handle;
     char type;
     char iseos;
     int (*read) ();
diff -r e3b32d39b47a main.c
--- a/main.c
+++ b/main.c
@@ -119,6 +119,42 @@
 #define help() fusage(stdout, 0)
 #define usage() fusage(stderr, 1)
 
+int support_remote_image;
+
+static void
+check_support_remote_image(void)
+{
+    char *env;
+
+    if ((env = getenv("MLTERM"))) {
+	char *p;
+	int major;
+	int minor;
+	int micro;
+
+	if (!(p = strchr(env,'.')))
+	    return;
+	*p = '\0';
+	major = atoi(env);
+	env = p + 1;
+
+	if (!(p = strchr(env,'.')))
+	    return;
+	*p = '\0';
+	minor = atoi(env);
+	env = p + 1;
+	micro = atoi(env) ;
+
+	if (major > 3 ||
+	    (major == 3 && (minor > 1 || (minor == 1 && micro >= 7)))) {
+	    support_remote_image = 1 ;
+	    set_environ( "W3M_USE_REMOTE_IMAGE","1");	/* for w3mimgdisplay */
+	}
+    }
+
+    return;
+}
+
 static void
 fversion(FILE * f)
 {
@@ -397,6 +433,7 @@
     wc_ces CodePage;
 #endif
 #endif
+    check_support_remote_image();
     GC_INIT();
 #if defined(ENABLE_NLS) || (defined(USE_M17N) && defined(HAVE_LANGINFO_CODESET))
     setlocale(LC_ALL, "");
@@ -660,6 +697,10 @@
 		}
 	    }
 #endif
+	    else if (!strcmp("-ri" , argv[i])) {
+	        support_remote_image = 1;
+		set_environ( "W3M_USE_REMOTE_IMAGE","1");	/* for w3mimgdisplay */
+	    }
 	    else if (!strcmp("-num", argv[i]))
 		showLineNum = TRUE;
 	    else if (!strcmp("-no-proxy", argv[i]))
diff -r e3b32d39b47a terms.c
--- a/terms.c
+++ b/terms.c
@@ -463,6 +463,65 @@
 
 #define MOVE(line,column)       writestr(tgoto(T_cm,column,line));
 
+void
+put_image(char *url, int x, int y, int w, int h, int sx, int sy, int sw, int sh)
+{
+    Str buf;
+    char *size ;
+
+    if (w > 0 && h > 0)
+	size = Sprintf("%dx%d",w,h)->ptr;
+    else
+	size = "";
+
+    MOVE(y,x);
+    buf = Sprintf("\x1b]5379;show_picture %s %s %dx%d+%d+%d\x07",url,size,sw,sh,sx,sy);
+    writestr(buf->ptr);
+    MOVE(Currentbuf->cursorY,Currentbuf->cursorX);
+}
+
+int
+get_pixel_per_cell(int *ppc, int *ppl)
+{
+    fd_set  rfd;
+    struct timeval tval;
+    char buf[100];
+    char *p;
+    ssize_t len;
+    ssize_t left;
+    int wp,hp,wc,hc;
+    int i;
+
+    fputs("\x1b[14t\x1b[18t",ttyf); flush_tty();
+
+    p = buf;
+    left = sizeof(buf) - 1;
+    for (i = 0; i < 5; i++) {
+	tval.tv_usec = 500000;	/* 0.5 sec */
+	tval.tv_sec = 0;
+	FD_SET(tty,&rfd);
+	if (select(tty+1,&rfd,NULL,NULL,&tval) <= 0 || ! FD_ISSET(tty,&rfd)) {
+	    continue;
+	}
+
+	if ((len = read(tty,p,left)) <= 0) {
+	    return 0;
+	}
+	p[len] = '\0';
+
+	if (sscanf(buf,"\x1b[4;%d;%dt\x1b[8;%d;%dt",&hp,&wp,&hc,&wc) == 4) {
+	    *ppc = wp / wc;
+	    *ppl = hp / hc;
+
+	    return 1;
+	}
+	p = buf + len;
+	left -= len;
+    }
+
+    return 0;
+}
+
 #ifdef USE_MOUSE
 #define W3M_TERM_INFO(name, title, mouse)	name, title, mouse
 #define NEED_XTERM_ON   (1)
diff -r e3b32d39b47a w3mimg/x11/x11_w3mimg.c
--- a/w3mimg/x11/x11_w3mimg.c
+++ b/w3mimg/x11/x11_w3mimg.c
@@ -121,16 +121,21 @@
     if (self == NULL)
 	return 0;
     xi = (struct x11_info *)self->priv;
+#if defined(USE_IMLIB)
     if (xi == NULL)
 	return 0;
-#if defined(USE_IMLIB)
     if (!xi->id) {
 	xi->id = Imlib_init(xi->display);
 	if (!xi->id)
 	    return 0;
     }
 #elif defined(USE_GDKPIXBUF)
-    if (!xi->init_flag) {
+    if (!xi) {
+#if defined(USE_GTK2)
+	g_type_init();
+#endif
+    }
+    else if (!xi->init_flag) {
 #if defined(USE_GTK2)
 	g_type_init();
 #endif
@@ -138,7 +143,7 @@
 	xi->init_flag = TRUE;
     }
 #endif
-    if (!xi->imageGC) {
+    if (xi && !xi->imageGC) {
 	xi->imageGC = XCreateGC(xi->display, xi->parent, 0, NULL);
 	if (!xi->imageGC)
 	    return 0;
@@ -653,9 +658,11 @@
 
     if (self == NULL)
 	return 0;
+#if defined(USE_IMLIB) && defined(USE_IMLIB2)
     xi = (struct x11_info *)self->priv;
     if (xi == NULL)
 	return 0;
+#endif
 
 #if defined(USE_IMLIB)
     im = Imlib_load_image(xi->id, fname);
@@ -755,6 +762,9 @@
 	return NULL;
     memset(wop, 0, sizeof(w3mimg_op));
 
+    if (getenv("W3M_USE_REMOTE_IMAGE"))
+	goto  end;
+
     xi = (struct x11_info *)malloc(sizeof(struct x11_info));
     if (xi == NULL)
 	goto error;
@@ -807,6 +817,7 @@
 
     wop->priv = xi;
 
+  end:
     wop->init = x11_init;
     wop->finish = x11_finish;
     wop->active = x11_active;
